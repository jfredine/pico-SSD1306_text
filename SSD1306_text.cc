#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "SSD1306_text.h"



// Font array initially taken from the Pico SSD1306 example
// and then re-organized with 128 entries to make direct ASCII
// symbol look up easy.  Patterns for more symbols
// have been added so that all visible symbols in the ASCII set
// should now be present.  Non-printable characters will be displayed
// as a space.

/**
 * Copyright (c) 2022 Raspberry Pi (Trading) Ltd.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

// Vertical bitmaps, A-Z, 0-9. Each is 8 pixels high and wide
// Theses are defined vertically to make them quick to copy to FB

const uint8_t SSD1306_text::font_[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // NUL
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SOH
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // STX
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // ETX
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // EOT
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // ENQ
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // ACK
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // BEL
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // BS
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // HT
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // LF
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // VT
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // FF
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // CR
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SO
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SI
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // DLE
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // DC1
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // DC2
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // DC3
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // DC4
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // NAK
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SYN
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // ETB
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // CAN
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // EM
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SUB
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // ESC
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // FS
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // GS
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // RS
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // US
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // Space
    {0x00, 0x00, 0x6f, 0x6f, 0x00, 0x00, 0x00, 0x00},  // !
    {0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00},  // "
    {0x24, 0x24, 0x7f, 0x24, 0x7f, 0x24, 0x24, 0x00},  // #
    {0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x10, 0x00, 0x00},  // $ 
    {0x00, 0x40, 0x22, 0x12, 0x48, 0x44, 0x02, 0x00},  // %
    {0x00, 0x36, 0x4D, 0x4d, 0x52, 0x20, 0x50, 0x00},  // &
    {0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00},  // '
    {0x00, 0x1c, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00},  // (
    {0x00, 0x00, 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00},  // )
    {0x44, 0x24, 0x18, 0x0f, 0x18, 0x24, 0x44, 0x00},  // *
    {0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00},  // +
    {0x00, 0xb0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00},  // ,
    {0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00},  // -
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},  // .
    {0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00},  // /
    {0x3e, 0x41, 0x41, 0x49, 0x41, 0x41, 0x3e, 0x00},  // 0
    {0x00, 0x00, 0x42, 0x7f, 0x40, 0x00, 0x00, 0x00},  // 1
    {0x30, 0x49, 0x49, 0x49, 0x49, 0x46, 0x00, 0x00},  // 2
    {0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x36, 0x00},  // 3
    {0x3f, 0x20, 0x20, 0x78, 0x20, 0x20, 0x00, 0x00},  // 4
    {0x4f, 0x49, 0x49, 0x49, 0x49, 0x30, 0x00, 0x00},  // 5
    {0x3f, 0x48, 0x48, 0x48, 0x48, 0x48, 0x30, 0x00},  // 6
    {0x01, 0x01, 0x01, 0x61, 0x31, 0x0d, 0x03, 0x00},  // 7
    {0x36, 0x49, 0x49, 0x49, 0x49, 0x49, 0x36, 0x00},  // 8
    {0x06, 0x09, 0x09, 0x09, 0x09, 0x09, 0x7f, 0x00},  // 9
    {0x00, 0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00},  // :
    {0x00, 0x00, 0x00, 0x5b, 0x3b, 0x00, 0x00, 0x00},  // ;
    {0x08, 0x14, 0x14, 0x22, 0x22, 0x41, 0x41, 0x00},  // <
    {0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00},  // =
    {0x41, 0x41, 0x22, 0x22, 0x14, 0x14, 0x08, 0x00},  // >
    {0x00, 0x00, 0x06, 0x01, 0x59, 0x06, 0x00, 0x00},  // ?
    {0x1c, 0x22, 0x59, 0x65, 0x65, 0x5a, 0x2c, 0x00},  // @
    {0x78, 0x14, 0x12, 0x11, 0x12, 0x14, 0x78, 0x00},  // A
    {0x7f, 0x49, 0x49, 0x49, 0x49, 0x49, 0x3e, 0x00},  // B
    {0x3e, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, 0x00},  // C
    {0x7f, 0x41, 0x41, 0x41, 0x41, 0x22, 0x1c, 0x00},  // D
    {0x7f, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x00},  // E
    {0x7f, 0x09, 0x09, 0x09, 0x09, 0x01, 0x01, 0x00},  // F
    {0x7f, 0x41, 0x41, 0x41, 0x51, 0x51, 0x73, 0x00},  // G
    {0x7f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, 0x00},  // H
    {0x00, 0x00, 0x41, 0x7f, 0x41, 0x00, 0x00, 0x00},  // I
    {0x20, 0x40, 0x40, 0x3f, 0x00, 0x00, 0x00, 0x00},  // J
    {0x00, 0x7f, 0x08, 0x08, 0x14, 0x22, 0x41, 0x00},  // K
    {0x7f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00},  // L
    {0x7f, 0x02, 0x04, 0x08, 0x04, 0x02, 0x7f, 0x00},  // M
    {0x7f, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7f, 0x00},  // N
    {0x3e, 0x41, 0x41, 0x41, 0x41, 0x41, 0x3e, 0x00},  // O
    {0x7f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00},  // P
    {0x3e, 0x41, 0x41, 0x49, 0x51, 0x61, 0x7e, 0x00},  // Q
    {0x7f, 0x11, 0x11, 0x11, 0x31, 0x51, 0x0e, 0x00},  // R
    {0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x00},  // S
    {0x01, 0x01, 0x01, 0x7f, 0x01, 0x01, 0x01, 0x00},  // T
    {0x3f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3f, 0x00},  // U
    {0x0f, 0x10, 0x20, 0x40, 0x20, 0x10, 0x0f, 0x00},  // V
    {0x7f, 0x20, 0x10, 0x08, 0x10, 0x20, 0x7f, 0x00},  // W
    {0x00, 0x41, 0x22, 0x14, 0x14, 0x22, 0x41, 0x00},  // X
    {0x01, 0x02, 0x04, 0x78, 0x04, 0x02, 0x01, 0x00},  // Y
    {0x41, 0x61, 0x59, 0x45, 0x43, 0x41, 0x00, 0x00},  // Z
    {0x00, 0x00, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00},  // [
    {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80},  // [back slash]
    {0x00, 0x00, 0x00, 0x41, 0x41, 0x7f, 0x00, 0x00},  // ]
    {0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00},  // ^
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00},  // _
    {0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00},  // `
    {0x00, 0x00, 0x32, 0x4a, 0x4a, 0x7c, 0x40, 0x00},  // a
    {0x00, 0x7f, 0x28, 0x44, 0x44, 0x48, 0x30, 0x00},  // b
    {0x00, 0x3c, 0x42, 0x42, 0x42, 0x24, 0x00, 0x00},  // c
    {0x00, 0x30, 0x48, 0x44, 0x44, 0x28, 0x7f, 0x00},  // d
    {0x00, 0x3c, 0x4a, 0x49, 0x49, 0x4a, 0x46, 0x00},  // e
    {0x08, 0x08, 0x7e, 0x09, 0x01, 0x06, 0x00, 0x00},  // f
    {0x00, 0x00, 0x4c, 0x52, 0x52, 0x7e, 0x00, 0x00},  // g
    {0x00, 0x7f, 0x10, 0x08, 0x08, 0x70, 0x00, 0x00},  // h
    {0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x00},  // i
    {0x20, 0x40, 0x40, 0x3d, 0x00, 0x00, 0x00, 0x00},  // j
    {0x00, 0x7f, 0x10, 0x08, 0x14, 0x22, 0x40, 0x00},  // k
    {0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00},  // l
    {0x7c, 0x08, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00},  // m
    {0x00, 0x7c, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00},  // n
    {0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00},  // o
    {0x00, 0x7e, 0x0c, 0x12, 0x12, 0x0c, 0x00, 0x00},  // p
    {0x06, 0x09, 0x09, 0x3f, 0x40, 0x40, 0x20, 0x00},  // q
    {0x00, 0x7c, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00},  // r
    {0x00, 0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00},  // s
    {0x00, 0x04, 0x04, 0x3e, 0x44, 0x44, 0x00, 0x00},  // t
    {0x00, 0x3c, 0x40, 0x40, 0x40, 0x7c, 0x00, 0x00},  // u
    {0x00, 0x1e, 0x20, 0x40, 0x20, 0x1e, 0x00, 0x00},  // v
    {0x38, 0x40, 0x40, 0x30, 0x40, 0x40, 0x38, 0x00},  // w
    {0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00},  // x
    {0x00, 0x40, 0x5c, 0x20, 0x10, 0x0c, 0x00, 0x00},  // y
    {0x00, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00, 0x00},  // z
    {0x00, 0x08, 0x2a, 0x55, 0x41, 0x41, 0x00, 0x00},  // {
    {0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00},  // |
    {0x00, 0x41, 0x41, 0x55, 0x2a, 0x08, 0x00, 0x00},  // }
    {0x00, 0x10, 0x08, 0x08, 0x10, 0x10, 0x08, 0x00},  // ~
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}   // DEL
};


//
// SSD1306_text::SSD1306_text
// Arguments: height -- Height of the display in pixels
//            width -- Width of the display in pixels
//            init -- True to initialize I2C system
//            i2c_addr -- Address of the display on the I2C bus
//            i2c -- One of the I2C blocks in the pico (i2c0 or i2c1)
//            sda -- GPIO to be used for SDA of the I2C bus
//                   (must be valid for the i2c chosen)
//            scl -- GPIO to be used for SCL on the I2C bus
//                   (must be valid for the i2c chosen)
//            i2c_frequency -- Frequency of I2C interface
//                             (may be set to 0 to skip I2C initialization)
// Returns: Nothing
//
// Constructor which sets up I2C and initializes the display
//

SSD1306_text::SSD1306_text(uint height, uint width,
                           uint i2c_addr,
                           i2c_inst_t *i2c, uint sda, uint scl,
                           uint i2c_frequency) {

    height_ = height;
    width_ = width;
    i2c_ = i2c;
    i2c_addr_ = i2c_addr;
    cursor_pos_.row = 0;
    cursor_pos_.col = 0;

    if (i2c_frequency > 0) {
        i2c_init(i2c, i2c_frequency);
        gpio_set_function(sda, GPIO_FUNC_I2C);
        gpio_set_function(scl, GPIO_FUNC_I2C);
        gpio_pull_up(sda);
        gpio_pull_up(scl);
    }

    buffer_size_ = width * (((height_ - 1) / 8) + 1);
    buffer_ = reinterpret_cast<uint8_t *>(malloc(sizeof(uint8_t) * buffer_size_));
    memset(buffer_, 0, buffer_size_);

    uint8_t cmds[] = {
        DISP_SLEEP,
        SET_MEM_MODE,
        0x00,
        SET_DISP_START,
        SET_SEG_MAP_REVERSE,
        SET_MUX_RATIO,
        static_cast<uint8_t>(height_ - 1),
        SET_COM_SCAN_REVERSE,
        SET_DISP_OFFSET,
        0x00,
        SET_COM_HW_CFG,
        0x12,
        SET_CLK,
        0x80,
        SET_PRE,
        0xF1,
        SET_VCOMH,
        0x30,
        SET_CONTRAST,
        0xff,
        DISP_ON_USE_RAM,
        DISP_NORMAL,
        SET_CHARGE_PUMP,
        0x14,
        DISABLE_SCROLL,
        DISP_WAKE
    };

    write_cmds(cmds, sizeof(cmds));
    update();
}


//
// SSD1306_text::clear
// Arguments: None
// Returns: Nothing
//
// Clear the display and set the cursor to the home position
//

void SSD1306_text::clear() {
    memset(buffer_, 0, buffer_size_);
    position(0, 0);
}


//
// SSD1306_text::clear_line
// Arguments: row -- Row of the display to clear
// Returns: Nothing
//
// Clear one line (row) of the display and set the cursor to the
// beginning of the line
//

void SSD1306_text::clear_line(uint row) {
    if (row > ((height_ - 1) / 8)) {
        return;
    }
    memset(&buffer_[row * width_], 0, width_ * 8);
    position(row, 0);
}


//
// SSD1306_text::position
// Arguments: row -- Row to reposition the cursor to
//            col -- column to reposition the cursor to
// Returns: Nothing
//
// Set the cursor position to the specified row and column
//

void SSD1306_text::position(uint row, uint col) {
    if ((row > ((height_ - 1) / 8))
        || (col  > (width_ - 1) / 8)) {
        return;
    }
    cursor_pos_.row = row;
    cursor_pos_.col = col;
}


//
// SD1306_text::write_string
// Arguments: str -- string to write to the screen
// Returns: Nothing
//
// Write a string to the screen.  The string must be null terminated.
//

void SSD1306_text::write_string(const char *str) {
    const char *cp;
    for (cp = str; *cp != '\0'; cp++) {
        char c = *cp;
        if (c == '\n') {
            cursor_pos_.row++;
            if (cursor_pos_.row == (height_ / 8)) {
                cursor_pos_.row = 0;
            }
            position(cursor_pos_.row, 0);
            clear_line(cursor_pos_.row);
        } else {
            write_data(font_[c], 8);
            cursor_pos_.col++;
            if (cursor_pos_.col == (width_ / 8)) {
                cursor_pos_.col = 0;
                cursor_pos_.row++;
                if (cursor_pos_.row == (height_ / 8)) {
                    cursor_pos_.row = 0;
                    position(cursor_pos_.row, 0);
                }
                clear_line(cursor_pos_.row);
            }
        }
    }
}


//
// SD1306_text::write_cmds
// Arguments: cmds -- array of command bytes to write
//            len -- size of the array
// Returns: Nothing
//
// Write a sequence of bytes as commands to the display using I2C
//

void SSD1306_text::write_cmds(const uint8_t *cmds, uint len) {
    uint8_t cmd_bytes[2];
    cmd_bytes[0] = 0x80;  // Co high, D/C# low
    for (uint i = 0; i < len; i++) {
        cmd_bytes[1] = cmds[i];
        i2c_write_blocking(i2c_, i2c_addr_, cmd_bytes, 2, false);
    }
}


//
// SD1306_text::write_cmds
// Arguments: cmd -- array of command bytes to write
//            len -- size of the array
// Returns: Nothing
//
// Write a sequence of bytes to the local display buffer.  The screen will
// not be updated until update() has been called
//

void SSD1306_text::write_data(const uint8_t *data, uint len) {
    uint start = (cursor_pos_.row * width_) + (cursor_pos_.col * 8);
    memcpy(&buffer_[start], data, len);
}


void SSD1306_text::update() {
    uint8_t cmds[6];

    cmds[0] = SET_LO_HI_COL_ADDR;
    cmds[1] = 0;
    cmds[2] = width_ - 1;
    cmds[3] = SET_LO_HI_PAGE_ADDR;
    cmds[4] = 0;
    cmds[5] = ((height_ - 1) / 8);
    write_cmds(cmds, sizeof(cmds));

    uint8_t buffer[129];
    uint write_len;
    uint written;

    buffer[0] = 0x40;  // Co low, D/C# high
    written = 0;
    while (written != buffer_size_) {
        write_len = ((buffer_size_ - written) > (sizeof(buffer) - 1))
                    ? sizeof(buffer) - 1
                    : (buffer_size_ - written);
        memcpy(&buffer[1], &buffer_[written], write_len);
        i2c_write_blocking(i2c_, i2c_addr_, buffer, write_len + 1, false);
        written += write_len;
    }
}
